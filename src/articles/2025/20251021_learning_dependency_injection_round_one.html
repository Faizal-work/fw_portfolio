<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Learning Dependency Injection Round 1: A Gamified Journey</title>
    <link rel="stylesheet" href="../../asset/drew.min.css" />
  </head>
  <body>
    <h1>
      Learning Dependency Injection : A Gamified Journey
      <small> <span class="date">21-October-2025</span> by Faizal.Work </small>
    </h1>
    <main>
      <article>
        <h2>Introduction</h2>
        <p>
          This document captures a hands-on learning journey through Dependency
          Injection (DI) in C#. Instead of passive learning, we used a gamified
          approach with a point system to make the learning process interactive
          and memorable.
        </p>

        <h3>The Game Rules</h3>
        <ul>
          <li><strong>Starting Points:</strong> 50</li>
          <li>
            <strong>Corrections:</strong> -2 to -5 points depending on severity
          </li>
          <li><strong>Wins:</strong> +1 point for each correct solution</li>
          <li>
            <strong>Goal:</strong> Learn all three types of DI through hands-on
            practice
          </li>
        </ul>

        <!-- Table of Contents -->
        <div class="toc" id="toc">
          <h2>üìë Table of Contents</h2>
          <ol>
            <li>
              <a href="#initial-code"
                >The Initial Problem (Tightly Coupled Code)</a
              >
            </li>
            <li>
              <a href="#learning-journey">The Learning Journey</a>
              <ol>
                <li><a href="#phase1">Phase 1: Constructor Injection</a></li>
                <li><a href="#phase2">Phase 2: Property Injection</a></li>
                <li><a href="#phase3">Phase 3: Method Injection</a></li>
              </ol>
            </li>
            <li><a href="#final-results">Final Results & Score Summary</a></li>
            <li><a href="#key-lessons">Key Lessons Learned</a></li>
            <li><a href="#comparison">Comparison of DI Types</a></li>
            <li>
              <a href="#final-code">The Final Solution (Complete Code)</a>
            </li>
            <li><a href="#conclusion">Conclusion</a></li>
          </ol>
        </div>

        <h2 id="initial-code">The Initial Problem: Tightly Coupled Code</h2>
        <p>
          We started with code that "works" but has serious design issues. This
          is the <strong>BEFORE</strong> state - the problematic code we need to
          fix:
        </p>

        <div class="code-legend">
          <strong>Code Highlighting Legend:</strong><br />
          <span class="code-legend-item">
            <span class="code-legend-box error"></span>
            <span>Problems / Errors</span>
          </span>
          <span class="code-legend-item">
            <span class="code-legend-box correct"></span>
            <span>Solutions / Correct Code</span>
          </span>
          <span class="code-legend-item">
            <span class="code-legend-box highlight"></span>
            <span>Important Changes</span>
          </span>
        </div>

        <pre><code>public class User
{
    public string Name { get; set; }
    public string Email { get; set; }
    private decimal _balance;

    public User(string name, string email, decimal initialBalance)
    {
        Name = name;
        Email = email;
        _balance = initialBalance;
    }

    public void SendWelcomeEmail()
    {
        <span class="error">EmailService emailService = new EmailService();</span> <span class="comment-error">// ‚ùå Tight coupling!</span>
        emailService.Send(Email, "Welcome!", $"Hello {Name}...");
    }

    public bool Withdraw(decimal amount)
    {
        <span class="error">BankAccount account = new BankAccount(_balance);</span> <span class="comment-error">// ‚ùå Creates fresh each time!</span>
        if (account.HasSufficientFunds(amount))
        {
            _balance = account.Deduct(amount);
            <span class="error">EmailService emailService = new EmailService();</span> <span class="comment-error">// ‚ùå Again!</span>
            emailService.Send(Email, "Withdrawal Notification", ...);
            return true;
        }
        return false;
    }
}</code></pre>

        <h3>Problems Identified</h3>
        <ul>
          <li>
            <strong>Tight Coupling:</strong> User creates its own dependencies
            with <code>new</code>
          </li>
          <li>
            <strong>Hard to Test:</strong> Can't mock EmailService or
            BankAccount
          </li>
          <li>
            <strong>Hard to Change:</strong> Want SMS instead? Must modify User
            class
          </li>
          <li>
            <strong>Violates Dependency Inversion Principle:</strong> High-level
            module depends on low-level implementations
          </li>
        </ul>

        <h2 id="learning-journey">The Learning Journey</h2>
        <p>
          Now let's walk through the journey of fixing these problems, learning
          from mistakes along the way.
        </p>

        <h2 id="phase1">Phase 1: Constructor Injection</h2>
        <p><strong>Score at start: 50 points</strong></p>

        <h3>Common Mistakes Made</h3>
        <details>
          <summary>
            Mistake #1: Inheritance Instead of Composition
            <span class="score-badge penalty">-4 points</span>
          </summary>
          <pre><code><span class="error">public class User : IEmailService</span> <span class="comment-error">// ‚ùå WRONG!</span>
{
    // User shouldn't BE an email service, it should USE one
}</code></pre>
          <p>
            <strong>Lesson:</strong> Use "has-a" relationship (composition), not
            "is-a" (inheritance)
          </p>
        </details>

        <details>
          <summary>
            Mistake #2: Implementation in Interface
            <span class="score-badge penalty">-4 points</span>
          </summary>
          <pre><code>public interface IEmailService
{
    <span class="error">void Send(string to, string subject, string body)
    {
        Console.WriteLine(...); // ‚ùå Interfaces don't have bodies in C#!
    }</span>
}</code></pre>
          <p>
            <strong>Lesson:</strong> Interfaces are contracts - just signatures,
            no implementation
          </p>
        </details>

        <details>
          <summary>
            Mistake #3: Still Creating Dependencies
            <span class="score-badge penalty">-4 points</span>
          </summary>
          <pre><code>public User(IEmailService emailService)
{
    _emailService = emailService;
}

public void Withdraw(decimal amount)
{
    <span class="error">EmailService emailService = new EmailService();</span> <span class="comment-error">// ‚ùå Still doing new!</span>
}</code></pre>
          <p>
            <strong>Lesson:</strong> Use the injected dependency, don't create
            new ones
          </p>
        </details>

        <details>
          <summary>
            Mistake #4: Naming Inconsistency
            <span class="score-badge penalty">-3 points</span>
          </summary>
          <pre><code><span class="error">private readonly IEmailService emailService;</span> <span class="comment-error">// No underscore</span>
// but later:
<span class="error">_emailService = emailService;</span> <span class="comment-error">// With underscore</span></code></pre>
          <p><strong>Lesson:</strong> Be consistent with naming conventions</p>
        </details>

        <details>
          <summary>
            Mistake #5: Using Non-Existent Field
            <span class="score-badge penalty">-3 points</span>
          </summary>
          <pre><code><span class="error">// private decimal _balance; // Commented out
_balance = initialBalance;</span> <span class="comment-error">// ‚ùå But still using it!</span></code></pre>
          <p>
            <strong>Lesson:</strong> If you remove a field, update all
            references
          </p>
        </details>

        <h3>
          The Correct Solution <span class="score-badge bonus">+4 points</span>
        </h3>
        <pre><code>public interface IEmailService
{
    void Send(string to, string subject, string body); <span class="comment-correct">// ‚úÖ Just signature</span>
}

public interface IBankAccount
{
    bool HasSufficientFunds(decimal amount);
    decimal Deduct(decimal amount);
    decimal GetBalance();
}

public class User
{
    <span class="correct">private readonly IEmailService _emailService;</span> <span class="comment-correct">// ‚úÖ Store injected dependency</span>
    <span class="correct">private readonly IBankAccount _bankAccount;</span>
    
    public string Name { get; set; }
    public string Email { get; set; }

    <span class="correct">public User(string name, string email, 
                IEmailService emailService,</span> <span class="comment-correct">// ‚úÖ Inject through constructor</span>
                <span class="correct">IBankAccount bankAccount)</span>
    {
        Name = name;
        Email = email;
        <span class="correct">_emailService = emailService;</span> <span class="comment-correct">// ‚úÖ Store it</span>
        <span class="correct">_bankAccount = bankAccount;</span>
    }

    public void SendWelcomeEmail()
    {
        <span class="correct">_emailService.Send(Email, "Welcome!", $"Hello {Name}...");</span> <span class="comment-correct">// ‚úÖ Use injected</span>
    }

    public bool Withdraw(decimal amount)
    {
        if (_bankAccount.HasSufficientFunds(amount))
        {
            _bankAccount.Deduct(amount);
            decimal newBalance = _bankAccount.GetBalance();
            <span class="correct">_emailService.Send(Email, "Withdrawal", $"Withdrew ${amount}...");</span>
            return true;
        }
        return false;
    }
}

// Implementation classes
public class EmailService : IEmailService
{
    public void Send(string to, string subject, string body)
    {
        Console.WriteLine($"Sending email to {to}: {subject} - {body}");
    }
}

public class BankAccount : IBankAccount
{
    private decimal _balance;
    
    public BankAccount(decimal initialBalance)
    {
        _balance = initialBalance;
    }
    
    public bool HasSufficientFunds(decimal amount) => _balance >= amount;
    
    public decimal Deduct(decimal amount)
    {
        _balance -= amount;
        return _balance;
    }
    
    public decimal GetBalance() => _balance;
}</code></pre>

        <h2 id="phase2">Phase 2: Property Injection</h2>
        <p><strong>Score: 41 points</strong></p>

        <h3>Understanding Property Injection</h3>
        <p>
          Property Injection makes dependencies <strong>optional</strong>.
          Unlike Constructor Injection where dependencies are required, Property
          Injection allows objects to exist and function without certain
          dependencies.
        </p>

        <h3>Common Mistakes Made</h3>
        <details>
          <summary>
            Mistake #6: Code Execution Inside Class
            <span class="score-badge penalty">-3 points</span>
          </summary>
          <pre><code>public class User
{
    public IEmailService EmailService { get; set; }
    
    <span class="error">var user = new User(...);
    user.EmailService = new EmailService();</span> <span class="comment-error">// ‚ùå Can't execute code here!</span>
}</code></pre>
          <p>
            <strong>Lesson:</strong> Execution code goes in methods or Main, not
            in class body
          </p>
        </details>

        <details>
          <summary>
            Mistake #7: Wrong Variable Name
            <span class="score-badge penalty">-2 points</span>
          </summary>
          <pre><code><span class="error">_emailService.Send(...)</span> <span class="comment-error">// ‚ùå Field doesn't exist anymore with property injection</span></code></pre>
          <p>
            <strong>Lesson:</strong> Use the property name, not the old field
            name
          </p>
        </details>

        <h3>
          The Correct Solution <span class="score-badge bonus">+3 points</span>
        </h3>
        <pre><code>public class User
{
    <span class="highlight">private readonly IBankAccount _bankAccount;</span> <span class="comment-correct">// Constructor Injection</span>
    <span class="correct">public IEmailService EmailService { get; set; }</span> <span class="comment-correct">// ‚úÖ Property Injection</span>
    
    public string Name { get; set; }
    public string Email { get; set; }

    public User(string name, string email, IBankAccount bankAccount)
    {
        Name = name;
        Email = email;
        _bankAccount = bankAccount;
        <span class="comment-correct">// EmailService NOT set here - it's optional</span>
    }

    public void SendWelcomeEmail()
    {
        <span class="correct">EmailService?.Send(Email, "Welcome!", ...);</span> <span class="comment-correct">// ‚úÖ Null-conditional operator</span>
    }

    public bool Withdraw(decimal amount)
    {
        if (_bankAccount.HasSufficientFunds(amount))
        {
            _bankAccount.Deduct(amount);
            decimal newBalance = _bankAccount.GetBalance();
            <span class="correct">EmailService?.Send(Email, "Withdrawal", ...);</span> <span class="comment-correct">// ‚úÖ Check for null</span>
            return true;
        }
        return false;
    }
}

// Usage:
var bankAccount = new BankAccount(1000);
<span class="correct">var user = new User("John", "a@g.com", bankAccount)
{
    EmailService = new EmailService()</span> <span class="comment-correct">// ‚úÖ Set property after construction</span>
<span class="correct">};</span>
user.SendWelcomeEmail();</code></pre>

        <h2 id="phase3">Phase 3: Method Injection</h2>
        <p><strong>Score: 42 points</strong></p>

        <h3>Understanding Method Injection</h3>
        <p>
          Method Injection passes the dependency as a
          <strong>parameter to a specific method</strong>
          that needs it. This provides maximum flexibility - different calls can
          use different implementations.
        </p>

        <h3>Common Mistakes Made</h3>
        <details>
          <summary>
            Mistake #8: Wrong Responsibility
            <span class="score-badge penalty">-3 points</span>
          </summary>
          <pre><code>public interface IBankAccount
{
    <span class="error">void Deposit(decimal amount, IEmailService notificationService);</span> <span class="comment-error">// ‚ùå</span>
}

public class BankAccount : IBankAccount
{
    public void Deposit(decimal amount, IEmailService notificationService)
    {
        _balance += amount;
        <span class="error">notificationService.Send(...);</span> <span class="comment-error">// ‚ùå BankAccount shouldn't know about emails!</span>
    }
}</code></pre>
          <p>
            <strong>Lesson:</strong> Keep responsibilities separate. BankAccount
            handles money, User handles notifications
          </p>
        </details>

        <details>
          <summary>
            Mistake #9: Syntax Error with Types
            <span class="score-badge penalty">-2 points</span>
          </summary>
          <pre><code><span class="error">_bankAccount.Deposit(decimal amount, IEmailService notificationService);</span> <span class="comment-error">// ‚ùå</span></code></pre>
          <p>
            <strong>Lesson:</strong> Pass variables, not types. Should be:
            <code>_bankAccount.Deposit(amount)</code>
          </p>
        </details>

        <details>
          <summary>
            Mistake #10: Assigning Void Return
            <span class="score-badge penalty">-2 points</span>
          </summary>
          <pre><code><span class="error">decimal newBalance = _bankAccount.Deposit(amount);</span> <span class="comment-error">// ‚ùå Deposit returns void!</span></code></pre>
          <p>
            <strong>Lesson:</strong> Check return types. Call separately if
            method returns void
          </p>
        </details>

        <details>
          <summary>
            Mistake #11: Missing Interface Parameter
            <span class="score-badge penalty">-2 points</span>
          </summary>
          <pre><code><span class="error">void Deposit();</span> <span class="comment-error">// ‚ùå Missing the amount parameter</span></code></pre>
          <p>
            <strong>Lesson:</strong> Interface and implementation signatures
            must match
          </p>
        </details>

        <h3>
          The Correct Solution <span class="score-badge bonus">+6 points</span>
        </h3>
        <pre><code>public interface IBankAccount
{
    bool HasSufficientFunds(decimal amount);
    decimal Deduct(decimal amount);
    decimal GetBalance();
    <span class="correct">void Deposit(decimal amount);</span> <span class="comment-correct">// ‚úÖ Simple, focused on money only</span>
}

public class BankAccount : IBankAccount
{
    private decimal _balance;
    
    public BankAccount(decimal initialBalance)
    {
        _balance = initialBalance;
    }
    
    <span class="correct">public void Deposit(decimal amount)</span> <span class="comment-correct">// ‚úÖ Just handles the deposit</span>
    {
        _balance += amount;
    }
    
    // ... other methods
}

public class User
{
    private readonly IBankAccount _bankAccount;
    public string Name { get; set; }
    public string Email { get; set; }
    public IEmailService EmailService { get; set; }

    <span class="comment-correct">// ‚úÖ Method Injection - dependency passed to specific method</span>
    <span class="correct">public void Deposit(decimal amount, IEmailService notificationService)</span>
    {
        <span class="correct">_bankAccount.Deposit(amount);</span> <span class="comment-correct">// Update balance</span>
        <span class="correct">decimal newBalance = _bankAccount.GetBalance();</span> <span class="comment-correct">// Get new balance</span>
        <span class="correct">notificationService.Send(Email, "Deposit Confirmation",</span> 
            $"Hello {Name}, you deposited ${amount}. New balance: ${newBalance}");
    }
}

// Usage - different email service per call:
<span class="correct">user.Deposit(1000, new EmailService());
user.Deposit(500, new SmsService());</span> <span class="comment-correct">// ‚úÖ Can use different implementation!</span></code></pre>

        <h2 id="final-results">Final Results</h2>
        <h3>Score Summary</h3>
        <ul>
          <li><strong>Starting Points:</strong> 50</li>
          <li>
            <strong>Total Corrections:</strong> -13 points (from 11 distinct
            mistakes)
          </li>
          <li><strong>Total Wins:</strong> +12 points</li>
          <li>
            <strong>Final Score:</strong>
            <span class="score-badge">37 points</span>
          </li>
        </ul>

        <h2 id="key-lessons">Key Lessons Learned</h2>
        <ol>
          <li>
            <strong>Separation of Concerns:</strong> Each class should have one
            responsibility
          </li>
          <li>
            <strong>Interfaces Define Contracts:</strong> Just signatures, no
            implementation
          </li>
          <li>
            <strong>Composition Over Inheritance:</strong> "Has-a" not "is-a"
          </li>
          <li>
            <strong>Don't Create Dependencies:</strong> Use injected ones
            instead of <code>new</code>
          </li>
          <li>
            <strong>Null Safety:</strong> Use <code>?.</code> operator for
            optional dependencies
          </li>
          <li>
            <strong>Return Types Matter:</strong> Check if methods return values
            before assigning
          </li>
          <li>
            <strong>Right Responsibility in Right Place:</strong> Method
            injection goes where the logic lives
          </li>
        </ol>

        <h2 id="comparison">Comparison of DI Types</h2>
        <table>
          <thead>
            <tr>
              <th>Aspect</th>
              <th>Constructor Injection</th>
              <th>Property Injection</th>
              <th>Method Injection</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><strong>When Set</strong></td>
              <td>At object creation</td>
              <td>After object creation</td>
              <td>At method call</td>
            </tr>
            <tr>
              <td><strong>Required?</strong></td>
              <td class="red">Yes - must provide</td>
              <td class="yellow">No - optional</td>
              <td class="blue">Per method call</td>
            </tr>
            <tr>
              <td><strong>Mutability</strong></td>
              <td class="red">Immutable (readonly)</td>
              <td class="yellow">Can change</td>
              <td class="blue">Different per call</td>
            </tr>
            <tr>
              <td><strong>Example</strong></td>
              <td><code>new User(..., bankAccount)</code></td>
              <td><code>user.EmailService = service</code></td>
              <td><code>user.Deposit(100, service)</code></td>
            </tr>
            <tr>
              <td><strong>Best For</strong></td>
              <td>Critical dependencies</td>
              <td>Optional features</td>
              <td>Per-operation needs</td>
            </tr>
            <tr>
              <td><strong>Testing</strong></td>
              <td>Easy - pass mocks</td>
              <td>Easy - set test double</td>
              <td>Easy - pass mock per test</td>
            </tr>
          </tbody>
        </table>

        <h2 id="final-code">The Final Solution: Complete Code</h2>
        <p>
          This is the <strong>AFTER</strong> state - the refactored code with
          all three DI types working together:
        </p>

        <pre><code>// Interfaces
public interface IEmailService
{
    void Send(string to, string subject, string body);
}

public interface IBankAccount
{
    bool HasSufficientFunds(decimal amount);
    decimal Deduct(decimal amount);
    decimal GetBalance();
    void Deposit(decimal amount);
}

// User Class - Uses all three DI types
public class User
{
    <span class="comment-correct">// Constructor Injection - Required</span>
    <span class="correct">private readonly IBankAccount _bankAccount;</span>
    
    <span class="comment-correct">// Property Injection - Optional</span>
    <span class="correct">public IEmailService EmailService { get; set; }</span>
    
    public string Name { get; set; }
    public string Email { get; set; }

    <span class="correct">public User(string name, string email, IBankAccount bankAccount)</span>
    {
        Name = name;
        Email = email;
        <span class="correct">_bankAccount = bankAccount;</span>
    }

    public void SendWelcomeEmail()
    {
        <span class="correct">EmailService?.Send(Email, "Welcome!", $"Hello {Name}, welcome to our bank!");</span>
    }

    public bool Withdraw(decimal amount)
    {
        if (<span class="correct">_bankAccount.HasSufficientFunds(amount)</span>)
        {
            <span class="correct">_bankAccount.Deduct(amount);</span>
            decimal newBalance = <span class="correct">_bankAccount.GetBalance();</span>
            <span class="correct">EmailService?.Send(Email, "Withdrawal Notification",</span> 
                $"You withdrew ${amount}. New balance: ${newBalance}");
            return true;
        }
        return false;
    }

    <span class="comment-correct">// Method Injection - Flexible per-call</span>
    <span class="correct">public void Deposit(decimal amount, IEmailService notificationService)</span>
    {
        <span class="correct">_bankAccount.Deposit(amount);</span>
        decimal newBalance = <span class="correct">_bankAccount.GetBalance();</span>
        <span class="correct">notificationService.Send(Email, "Deposit Confirmation",</span> 
            $"Hello {Name}, you deposited ${amount}. New balance: ${newBalance}");
    }

    public decimal GetBalance() => <span class="correct">_bankAccount.GetBalance();</span>
}

// Implementation Classes
public class EmailService : IEmailService
{
    public void Send(string to, string subject, string body)
    {
        Console.WriteLine($"Sending email to {to}: {subject} - {body}");
    }
}

public class BankAccount : IBankAccount
{
    private decimal _balance;

    public BankAccount(decimal initialBalance)
    {
        _balance = initialBalance;
    }

    public bool HasSufficientFunds(decimal amount) => _balance >= amount;

    public decimal Deduct(decimal amount)
    {
        _balance -= amount;
        return _balance;
    }

    public decimal GetBalance() => _balance;

    public void Deposit(decimal amount)
    {
        _balance += amount;
    }
}

// Usage Example
public static void Main()
{
    <span class="comment-correct">// Constructor Injection</span>
    var bankAccount = <span class="correct">new BankAccount(1000);</span>
    var user = <span class="correct">new User("John", "a@g.com", bankAccount)</span>
    {
        <span class="comment-correct">// Property Injection</span>
        <span class="correct">EmailService = new EmailService()</span>
    };

    user.SendWelcomeEmail();
    
    <span class="comment-correct">// Method Injection</span>
    <span class="correct">user.Deposit(1000, new EmailService());</span>
    
    Console.WriteLine("Balance before withdrawal: $" + user.GetBalance());
    bool success = user.Withdraw(200);
    Console.WriteLine("Withdrawal success: " + success);
    Console.WriteLine("Balance after withdrawal: $" + user.GetBalance());
}</code></pre>

        <h2 id="conclusion">Conclusion</h2>
        <p>
          Through this gamified learning approach, we transformed
          tightly-coupled code into a flexible, testable, and maintainable
          design using all three types of Dependency Injection. The mistakes
          made along the way were valuable learning opportunities that
          reinforced key concepts.
        </p>

        <p>
          The most important takeaway:
          <strong
            >Dependency Injection isn't about perfect code on the first try -
            it's about understanding the principles and iteratively improving
            your design.</strong
          >
        </p>

        <div class="alert alert-info">
          <strong>Next Steps:</strong> Explore IoC (Inversion of Control)
          containers like Microsoft.Extensions.DependencyInjection, Autofac, or
          Ninject to automatically manage dependency injection in larger
          applications.
        </div>
      </article>

      <!-- Return link -->
      <span><a href="../../index.html">Main Page</a></span>
    </main>
    <footer>
      The
      <a href="https://git.sr.ht/~sircmpwn/drewdevault.com"
        >code for this site</a
      >
      is <a href="https://opensource.org/licenses/MIT">MIT</a>.
    </footer>
  </body>
</html>
