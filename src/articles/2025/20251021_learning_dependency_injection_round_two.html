<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Learning Dependency Injection Round 2: Task Manager System</title>
    <link rel="stylesheet" href="../../asset/drew.min.css" />
  </head>
  <body>
    <h1>
      Learning Dependency Injection Round 2: Task Manager System
      <small> <span class="date">21-October-2025</span> by Faizal.Work </small>
    </h1>
    <main>
      <article>
        <h2>Introduction</h2>
        <p>
          This is Round 2 of the gamified Dependency Injection learning journey.
          After completing the Bank System in Round 1, we tackle a new scenario:
          a Task Manager application. This round proved that
          <strong>naming consistency is the silent killer of scores</strong>,
          with the learner dropping from 52 points to just 3 points primarily
          due to naming mistakes!
        </p>

        <h3>Game Rules (Same as Round 1)</h3>
        <ul>
          <li><strong>Starting Points:</strong> 50</li>
          <li>
            <strong>Corrections:</strong> -2 to -5 points depending on severity
          </li>
          <li><strong>Wins:</strong> +1 to +5 points for correct solutions</li>
          <li><strong>Goal:</strong> Refactor through all three DI types</li>
        </ul>

        <!-- Table of Contents -->
        <div class="toc" id="toc">
          <h2>üìë Table of Contents</h2>
          <ol>
            <li>
              <a href="#initial-code"
                >The Initial Problem (Task Manager with Tight Coupling)</a
              >
            </li>
            <li><a href="#initial-analysis">Initial Problem Analysis</a></li>
            <li>
              <a href="#srp">Understanding Single Responsibility Principle</a>
            </li>
            <li>
              <a href="#learning-journey">The Learning Journey</a>
              <ol>
                <li>
                  <a href="#naming-nightmare"
                    >Phase 1: The Naming Nightmare (52 ‚Üí 3 points)</a
                  >
                </li>
                <li><a href="#phase2">Phase 2: Method Injection</a></li>
                <li><a href="#phase3">Phase 3: Main Method and Testing</a></li>
                <li><a href="#phase4">Phase 4: Knowledge Check</a></li>
              </ol>
            </li>
            <li>
              <a href="#final-code">The Final Solution (Complete Code)</a>
            </li>
            <li><a href="#score-journey">Score Journey Visualization</a></li>
            <li><a href="#key-lessons">Key Lessons Learned</a></li>
            <li><a href="#comparison">Comparison: Round 1 vs Round 2</a></li>
            <li><a href="#conclusion">Conclusion</a></li>
          </ol>
        </div>

        <h2 id="initial-code">
          The Initial Problem: Task Manager with Tight Coupling
        </h2>
        <p>
          We started with a task management system where tasks can be created,
          completed, and prioritized. This is the <strong>BEFORE</strong> state:
        </p>

        <div class="code-legend">
          <strong>Code Highlighting Legend:</strong><br />
          <span class="code-legend-item">
            <span class="code-legend-box error"></span>
            <span>Problems / Errors</span>
          </span>
          <span class="code-legend-item">
            <span class="code-legend-box correct"></span>
            <span>Solutions / Correct Code</span>
          </span>
          <span class="code-legend-item">
            <span class="code-legend-box highlight"></span>
            <span>Important Changes</span>
          </span>
        </div>

        <pre><code>public class TaskManager
{
    public string TaskName { get; set; }
    public string Description { get; set; }
    public bool IsCompleted { get; set; }
    public DateTime CreatedAt { get; set; }

    public TaskManager(string taskName, string description)
    {
        TaskName = taskName;
        Description = description;
        IsCompleted = false;
        CreatedAt = DateTime.Now;
    }

    public void CreateTask()
    {
        <span class="error">DatabaseStorage storage = new DatabaseStorage();</span> <span class="comment-error">// ‚ùå Tight coupling!</span>
        storage.Save(TaskName, Description, CreatedAt);
        
        <span class="error">NotificationService notifier = new NotificationService();</span> <span class="comment-error">// ‚ùå</span>
        notifier.SendNotification($"Task '{TaskName}' created!");
    }

    public void CompleteTask()
    {
        IsCompleted = true;
        
        <span class="error">DatabaseStorage storage = new DatabaseStorage();</span> <span class="comment-error">// ‚ùå Created again!</span>
        storage.Update(TaskName, IsCompleted);
        
        <span class="error">NotificationService notifier = new NotificationService();</span> <span class="comment-error">// ‚ùå Created again!</span>
        notifier.SendNotification($"Task '{TaskName}' completed!");
    }

    public void SetPriority(string priority)
    {
        <span class="error">Logger logger = new Logger();</span> <span class="comment-error">// ‚ùå Only used here</span>
        logger.Log($"Setting priority {priority} for task {TaskName}");
        
        <span class="error">DatabaseStorage storage = new DatabaseStorage();</span> <span class="comment-error">// ‚ùå Created yet again!</span>
        storage.UpdatePriority(TaskName, priority);
    }
}</code></pre>

        <h2 id="initial-analysis">Initial Problem Analysis</h2>
        <p>
          <strong>Score: 50 ‚Üí 51 points</strong>
          <span class="score-badge">+6 points</span>
          <span class="score-badge penalty">-5 points</span>
        </p>

        <h3>What Was Identified Correctly ‚úÖ</h3>
        <ul>
          <li>
            <strong>+3 points:</strong> Not testable, tightly coupled,
            dependencies recreated multiple times
          </li>
          <li>
            <strong>+2 points:</strong> DatabaseStorage and NotificationService
            should use Constructor Injection
          </li>
          <li>
            <strong>+1 point:</strong> Logger should be optional (Property
            Injection)
          </li>
        </ul>

        <h3>Mistakes Made ‚ùå</h3>
        <ul>
          <li>
            <strong>-3 points:</strong> Confused Method Injection with method
            names instead of dependencies
          </li>
          <li>
            <strong>-2 points:</strong> Missed Single Responsibility Principle
            violation
          </li>
        </ul>

        <div class="alert alert-info">
          <strong>Key Learning:</strong> Method Injection means passing a
          <em>dependency</em> as a method parameter, not just any method that
          needs attention. Logger is only used in <code>SetPriority()</code>,
          making it perfect for Method Injection.
        </div>

        <h2 id="srp">Understanding Single Responsibility Principle (SRP)</h2>
        <p>
          Before continuing with refactoring, we took a detour to understand
          SRP, a crucial principle that works hand-in-hand with Dependency
          Injection.
        </p>

        <h3>The Problem in TaskManager</h3>
        <p>TaskManager had <strong>FOUR responsibilities</strong>:</p>
        <ol>
          <li>Managing task state (properties, completion status)</li>
          <li>Deciding HOW to store data (creating DatabaseStorage)</li>
          <li>Deciding HOW to notify users (creating NotificationService)</li>
          <li>Deciding HOW to log (creating Logger)</li>
        </ol>

        <p>
          <strong>SRP says:</strong> A class should have
          <strong>one, and only one, reason to change.</strong>
          TaskManager would need to change if task properties change, storage
          method changes, notification method changes, OR logging format
          changes. That's four reasons!
        </p>

        <h3>The SRP Way</h3>
        <pre><code>// Each class has ONE responsibility:

<span class="comment-correct">// Manages task state ONLY</span>
public class Task { }

<span class="comment-correct">// Stores/retrieves tasks ONLY</span>
public interface ITaskStorage { }

<span class="comment-correct">// Notifies users ONLY</span>
public interface INotificationService { }

<span class="comment-correct">// Logs events ONLY</span>
public interface ILogger { }

<span class="comment-correct">// Coordinates task operations (orchestrator)</span>
public class TaskManager
{
    <span class="comment-correct">// Doesn't know HOW to store, notify, or log
    // Just coordinates these responsibilities</span>
}</code></pre>

        <h2 id="learning-journey">The Learning Journey</h2>

        <h2 id="naming-nightmare">
          Phase 1: The Naming Nightmare (52 ‚Üí 3 points)
        </h2>
        <p><strong>This is where things got rough!</strong></p>

        <h3>
          Attempt 1: Multiple Interface Issues
          <span class="score-badge penalty">-14 points</span>
        </h3>
        <p><strong>Score: 52 ‚Üí 38 points</strong></p>

        <details>
          <summary>
            Mistake Group 1: Interface Bodies
            <span class="score-badge penalty">-3 points</span>
          </summary>
          <pre><code>public interface ITaskStorage
{
    <span class="error">void Save(string name, string desc, DateTime created){}</span> <span class="comment-error">// ‚ùå Has body!</span>
}</code></pre>
          <p>
            <strong>Lesson:</strong> In C#, interfaces are contracts - just
            signatures with semicolons, no bodies!
          </p>
          <pre><code>public interface ITaskStorage
{
    <span class="correct">void Save(string name, string desc, DateTime created);</span> <span class="comment-correct">// ‚úÖ</span>
}</code></pre>
        </details>

        <details>
          <summary>
            Mistake Group 2: Properties Instead of Fields
            <span class="score-badge penalty">-3 points</span>
          </summary>
          <pre><code><span class="error">private readonly ITaskStorage DatabaseStorage { get; set; }</span> <span class="comment-error">// ‚ùå Contradictory!</span></code></pre>
          <p>
            <strong>Problem:</strong> <code>readonly</code> with
            <code>{ get; set; }</code> doesn't make sense. Use fields:
          </p>
          <pre><code><span class="correct">private readonly ITaskStorage _storage;</span> <span class="comment-correct">// ‚úÖ</span></code></pre>
        </details>

        <details>
          <summary>
            Mistake Group 3: No Constructor Injection
            <span class="score-badge penalty">-4 points</span>
          </summary>
          <pre><code><span class="error">public TaskManager(string taskName, string description)</span> <span class="comment-error">// ‚ùå Where are dependencies?</span>
{
    Name = taskName;
    <span class="comment-error">// No dependency injection!</span>
}</code></pre>
          <p><strong>Fix:</strong> Add dependencies to constructor:</p>
          <pre><code><span class="correct">public TaskManager(string taskName, string description,
                   ITaskStorage storage, INotificationService notifier)</span> <span class="comment-correct">// ‚úÖ</span>
{
    <span class="correct">_storage = storage;
    _notifier = notifier;</span>
}</code></pre>
        </details>

        <details>
          <summary>
            Mistake Group 4: Calling Interface Type
            <span class="score-badge penalty">-3 points</span>
          </summary>
          <pre><code><span class="error">ITaskStorage.Save(...)</span> <span class="comment-error">// ‚ùå Can't call methods on type!</span>
<span class="error">INotificationService.SendNotification(...)</span> <span class="comment-error">// ‚ùå</span></code></pre>
          <p><strong>Fix:</strong> Use the instance (field):</p>
          <pre><code><span class="correct">_storage.Save(...)</span> <span class="comment-correct">// ‚úÖ</span>
<span class="correct">_notifier.SendNotification(...)</span> <span class="comment-correct">// ‚úÖ</span></code></pre>
        </details>

        <h3>
          Attempt 2: Semicolon Massacre
          <span class="score-badge penalty">-16 points</span>
        </h3>
        <p><strong>Score: 38 ‚Üí 22 points</strong></p>

        <details>
          <summary>
            Missing Semicolons Everywhere
            <span class="score-badge penalty">-5 points</span>
          </summary>
          <pre><code><span class="comment-error">// In interfaces</span>
<span class="error">void Save(string name, string desc, DateTime created)</span> <span class="comment-error">// ‚ùå No semicolon!</span>
<span class="error">void Update(string name, bool completed)</span> <span class="comment-error">// ‚ùå</span>

<span class="comment-error">// On field declarations</span>
<span class="error">private readonly ITaskStorage DatabaseStorage</span> <span class="comment-error">// ‚ùå No semicolon!</span>
<span class="error">private readonly INotificationService NotificationService</span> <span class="comment-error">// ‚ùå</span></code></pre>
          <p>
            <strong>Lesson:</strong> Every statement in C# needs proper
            termination!
          </p>
        </details>

        <details>
          <summary>
            Wrong Field Naming
            <span class="score-badge penalty">-3 points</span>
          </summary>
          <pre><code><span class="error">private readonly ITaskStorage DatabaseStorage</span> <span class="comment-error">// ‚ùå PascalCase</span></code></pre>
          <p>
            <strong>C# Convention:</strong> Private fields use camelCase with
            underscore:
          </p>
          <pre><code><span class="correct">private readonly ITaskStorage _storage;</span> <span class="comment-correct">// ‚úÖ</span></code></pre>
        </details>

        <details>
          <summary>
            Constructor Assignment Disaster
            <span class="score-badge penalty">-4 points</span>
          </summary>
          <pre><code>public TaskManager(..., ITaskStorage storage, INotificationService notifier)
{
    <span class="error">_ITaskStorage storage;</span> <span class="comment-error">// ‚ùå Trying to DECLARE, not ASSIGN!</span>
    <span class="error">_INotificationService notifier;</span> <span class="comment-error">// ‚ùå</span>
}</code></pre>
          <p>
            <strong>The Horror:</strong> This tries to create NEW variables of
            types "_ITaskStorage" and "_INotificationService"!
          </p>
          <p><strong>Fix:</strong> ASSIGN parameters to fields:</p>
          <pre><code><span class="correct">_storage = storage;</span> <span class="comment-correct">// ‚úÖ field = parameter</span>
<span class="correct">_notifier = notifier;</span> <span class="comment-correct">// ‚úÖ</span></code></pre>
        </details>

        <h3>
          Attempt 3: The Mismatch Continues
          <span class="score-badge penalty">-11 points</span>
        </h3>
        <p><strong>Score: 22 ‚Üí 12 points</strong></p>

        <details>
          <summary>
            Field Name vs Usage Mismatch
            <span class="score-badge penalty">-6 points</span>
          </summary>
          <pre><code><span class="comment-error">// Declared these names:</span>
<span class="error">private readonly ITaskStorage DatabaseStorage;
private readonly INotificationService NotificationService;</span>

<span class="comment-error">// But used these names:</span>
<span class="error">_taskStorage = storage;</span> <span class="comment-error">// ‚ùå What is _taskStorage? Never declared!</span>
<span class="error">_taskStorage.Save(...);</span> <span class="comment-error">// ‚ùå This doesn't exist!</span></code></pre>
          <p>
            <strong>Critical Rule:</strong> Declaration name = Assignment name =
            Usage name!
          </p>
        </details>

        <h3>
          Attempt 4: Still Not Matching
          <span class="score-badge penalty">-9 points</span>
        </h3>
        <p>
          <strong>Score: 12 ‚Üí 3 points</strong> (The
          <span class="score-badge penalty">LOWEST POINT</span>)
        </p>

        <pre><code><span class="comment-error">// Declared:</span>
<span class="error">private readonly ITaskStorage DatabaseStorage;</span>

<span class="comment-error">// Assigned:</span>
<span class="error">_ITaskStorage = storage;</span> <span class="comment-error">// ‚ùå "_ITaskStorage" was never declared!</span>

<span class="comment-error">// Used:</span>
<span class="error">_ITaskStorage.Save(...);</span> <span class="comment-error">// ‚ùå This variable doesn't exist!</span></code></pre>

        <div class="alert alert-danger">
          <strong>The Core Problem:</strong> The field name must be IDENTICAL
          in:
          <ol>
            <li>
              Declaration: <code>private readonly IType _fieldName;</code>
            </li>
            <li>Assignment: <code>_fieldName = parameter;</code></li>
            <li>Usage: <code>_fieldName.Method();</code></li>
          </ol>
        </div>

        <h3>
          Attempt 5: Finally Correct!
          <span class="score-badge bonus">+10 points</span>
        </h3>
        <p><strong>Score: 3 ‚Üí 13 points</strong> (Recovery begins!)</p>

        <pre><code>public class TaskManager
{
    public string TaskName { get; set; }
    public string Description { get; set; }
    public bool IsCompleted { get; set; }
    public DateTime CreatedAt { get; set; }
    
    <span class="comment-correct">// ‚úÖ Declared with consistent names</span>
    <span class="correct">private readonly ITaskStorage _taskStorage;
    private readonly INotificationService _notificationService;</span>
    <span class="correct">public ILogger Logger { get; set; }</span>
    
    <span class="comment-correct">// ‚úÖ Constructor injection</span>
    <span class="correct">public TaskManager(string taskName, string description,
                       ITaskStorage storage, INotificationService notifier)</span>
    {
        TaskName = taskName;
        Description = description;
        IsCompleted = false;
        CreatedAt = DateTime.Now;
        
        <span class="comment-correct">// ‚úÖ Assignment uses SAME names as declaration</span>
        <span class="correct">_taskStorage = storage;
        _notificationService = notifier;</span>
    }
    
    <span class="comment-correct">// ‚úÖ Usage uses SAME names</span>
    public void CreateTask()
    {
        <span class="correct">_taskStorage.Save(TaskName, Description, CreatedAt);
        _notificationService.SendNotification($"Task '{TaskName}' created!");</span>
    }
}</code></pre>

        <h2 id="phase2">Phase 2: Method Injection</h2>
        <p>
          <strong>Score: 13 ‚Üí 15 points</strong>
          <span class="score-badge bonus">+3 points</span>
          <span class="score-badge penalty">-1 point</span>
        </p>

        <h3>The Challenge</h3>
        <p>
          Convert Logger from Property Injection to Method Injection for
          <code>SetPriority()</code>.
        </p>

        <h3>What Was Done Right ‚úÖ</h3>
        <ul>
          <li>
            <strong>+3 points:</strong> Added <code>ILogger logger</code> as
            method parameter
          </li>
          <li>
            Used <code>logger?.Log(...)</code> correctly with null-safe operator
          </li>
        </ul>

        <h3>Minor Issue ‚ùå</h3>
        <ul>
          <li>
            <strong>-1 point:</strong> Forgot to remove the
            <code>public ILogger Logger { get; set; }</code> property
          </li>
        </ul>

        <h3>Corrected Method Injection</h3>
        <pre><code>public class TaskManager
{
    <span class="highlight">private readonly ITaskStorage _taskStorage;
    private readonly INotificationService _notificationService;</span>
    <span class="comment-correct">// ‚úÖ No Logger property - using Method Injection instead!</span>
    
    <span class="correct">public void SetPriority(string priority, ILogger logger)</span> <span class="comment-correct">// ‚úÖ Injected here</span>
    {
        <span class="correct">logger?.Log($"Setting priority {priority} for task {TaskName}");</span>
        _taskStorage.UpdatePriority(TaskName, priority);
    }
}</code></pre>

        <h2 id="phase3">Phase 3: Main Method and Testing</h2>
        <p>
          <strong>Score: 15 ‚Üí 20 points</strong>
          <span class="score-badge bonus">+5 points</span>
        </p>

        <h3>Perfect Main Method ‚úÖ</h3>
        <pre><code>public static void Main()
{
    <span class="comment-correct">// Create implementations</span>
    var storage = new DatabaseStorage();
    var notifier = new NotificationService();
    
    <span class="comment-correct">// ‚úÖ Constructor Injection</span>
    <span class="correct">var taskTobeManaged = new TaskManager(
        "SaveTask",
        "Saving the Task",
        storage,
        notifier
    );</span>
    
    <span class="comment-correct">// Use the task manager</span>
    taskTobeManaged.CreateTask();
    taskTobeManaged.CompleteTask();
    
    <span class="comment-correct">// ‚úÖ Method Injection - pass logger just for this operation</span>
    <span class="correct">taskTobeManaged.SetPriority("High", new Logger());</span>
}</code></pre>

        <h2 id="phase4">Phase 4: Knowledge Check</h2>
        <p>
          <strong>Score: 20 ‚Üí 27 points (Final!)</strong>
          <span class="score-badge bonus">+7 points</span>
          <span class="score-badge penalty">-2 points</span>
        </p>

        <h3>Question 1: When to use Constructor Injection? ‚úÖ</h3>
        <p>
          <strong>Answer:</strong> When the service is required and critical to
          operation <span class="score-badge bonus">+2 points</span>
        </p>
        <p>
          <strong>Refinement:</strong> Use it when a dependency is
          <strong>critical</strong>, regardless of frequency. Even if used only
          once, if the object can't function without it, use Constructor
          Injection.
        </p>

        <h3>Question 2: When to use Method Injection? ‚ùå</h3>
        <p>
          <strong>Incorrect Answer:</strong> "When the service is optional"
          <span class="score-badge penalty">-2 points</span>
        </p>
        <p>
          <strong>Correction:</strong> That's Property Injection! Method
          Injection is for:
        </p>
        <ul>
          <li>Different implementations per call</li>
          <li>Only ONE operation needs it</li>
          <li>Maximum flexibility per method</li>
        </ul>

        <h3>Question 3: Why is naming consistency important? ‚úÖ</h3>
        <p>
          <strong>Answer:</strong> Developer clarity, compiler needs, avoid
          errors <span class="score-badge bonus">+2 points</span>
        </p>
        <p>
          All correct! If you declare <code>_fieldName</code> but use
          <code>_differentName</code>, the compiler literally cannot find the
          variable.
        </p>

        <h3>Scenario Quiz: Perfect 4/4! ‚úÖ</h3>
        <p>
          <strong
            ><span class="score-badge bonus">+5 points</span> for perfect
            application!</strong
          >
        </p>
        <table>
          <thead>
            <tr>
              <th>Scenario</th>
              <th>Answer</th>
              <th>Result</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Database Connection</td>
              <td>Constructor</td>
              <td class="blue">‚úÖ Critical dependency</td>
            </tr>
            <tr>
              <td>Email (only in SendReport)</td>
              <td>Method</td>
              <td class="blue">‚úÖ One operation</td>
            </tr>
            <tr>
              <td>Theme Preference</td>
              <td>Property</td>
              <td class="blue">‚úÖ Optional, runtime change</td>
            </tr>
            <tr>
              <td>Authentication Token</td>
              <td>Constructor</td>
              <td class="blue">‚úÖ Required per request</td>
            </tr>
          </tbody>
        </table>

        <h2 id="final-code">The Final Solution: Complete Code</h2>
        <p>
          This is the <strong>AFTER</strong> state - the refactored code with
          proper Dependency Injection:
        </p>

        <pre><code><span class="comment-correct">// Interfaces</span>
public interface ITaskStorage
{
    void Save(string name, string desc, DateTime created);
    void Update(string name, bool completed);
    void UpdatePriority(string name, string priority);
}

public interface INotificationService
{
    void SendNotification(string message);
}

public interface ILogger
{
    void Log(string message);
}

<span class="comment-correct">// TaskManager - Demonstrates all three DI types</span>
public class TaskManager
{
    public string TaskName { get; set; }
    public string Description { get; set; }
    public bool IsCompleted { get; set; }
    public DateTime CreatedAt { get; set; }
    
    <span class="comment-correct">// Constructor Injection - Required dependencies</span>
    <span class="correct">private readonly ITaskStorage _taskStorage;
    private readonly INotificationService _notificationService;</span>
    
    <span class="correct">public TaskManager(string taskName, string description,
                       ITaskStorage storage,
                       INotificationService notifier)</span>
    {
        TaskName = taskName;
        Description = description;
        IsCompleted = false;
        CreatedAt = DateTime.Now;
        <span class="correct">_taskStorage = storage;
        _notificationService = notifier;</span>
    }
    
    public void CreateTask()
    {
        <span class="correct">_taskStorage.Save(TaskName, Description, CreatedAt);
        _notificationService.SendNotification($"Task '{TaskName}' created successfully!");</span>
    }
    
    public void CompleteTask()
    {
        IsCompleted = true;
        <span class="correct">_taskStorage.Update(TaskName, IsCompleted);
        _notificationService.SendNotification($"Task '{TaskName}' completed!");</span>
    }
    
    <span class="comment-correct">// Method Injection - Flexible per-call dependency</span>
    <span class="correct">public void SetPriority(string priority, ILogger logger)</span>
    {
        <span class="correct">logger?.Log($"Setting priority {priority} for task {TaskName}");</span>
        _taskStorage.UpdatePriority(TaskName, priority);
    }
    
    public static void Main()
    {
        var storage = new DatabaseStorage();
        var notifier = new NotificationService();
        
        <span class="correct">var taskTobeManaged = new TaskManager(
            "SaveTask",
            "Saving the Task",
            storage,
            notifier
        );</span>
        
        taskTobeManaged.CreateTask();
        taskTobeManaged.CompleteTask();
        <span class="correct">taskTobeManaged.SetPriority("High", new Logger());</span>
    }
}

<span class="comment-correct">// Implementation Classes</span>
public class DatabaseStorage : ITaskStorage
{
    public void Save(string name, string desc, DateTime created)
    {
        Console.WriteLine($"Saving to database: {name}");
    }
    
    public void Update(string name, bool completed)
    {
        Console.WriteLine($"Updating task {name}: Completed = {completed}");
    }
    
    public void UpdatePriority(string name, string priority)
    {
        Console.WriteLine($"Updating priority for {name}: {priority}");
    }
}

public class NotificationService : INotificationService
{
    public void SendNotification(string message)
    {
        Console.WriteLine($"üìß Notification: {message}");
    }
}

public class Logger : ILogger
{
    public void Log(string message)
    {
        Console.WriteLine($"[LOG] {message}");
    }
}</code></pre>

        <h2 id="score-journey">Score Journey Visualization</h2>
        <table>
          <thead>
            <tr>
              <th>Phase</th>
              <th>Score</th>
              <th>Change</th>
              <th>Key Event</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Start</td>
              <td>50</td>
              <td>-</td>
              <td>Fresh start</td>
            </tr>
            <tr>
              <td>Problem Analysis</td>
              <td>51</td>
              <td class="blue">+1</td>
              <td>Good understanding</td>
            </tr>
            <tr>
              <td>Logger Question</td>
              <td>52</td>
              <td class="blue">+1</td>
              <td>Correct answer</td>
            </tr>
            <tr>
              <td>Attempt 1</td>
              <td>38</td>
              <td class="red">-14</td>
              <td>Interface bodies, property fields</td>
            </tr>
            <tr>
              <td>Attempt 2</td>
              <td>22</td>
              <td class="red">-16</td>
              <td>Missing semicolons everywhere</td>
            </tr>
            <tr>
              <td>Attempt 3</td>
              <td>12</td>
              <td class="red">-10</td>
              <td>Name mismatch continues</td>
            </tr>
            <tr>
              <td>Attempt 4</td>
              <td class="red">3</td>
              <td class="red">-9</td>
              <td><strong>LOWEST POINT</strong></td>
            </tr>
            <tr>
              <td>Attempt 5</td>
              <td>13</td>
              <td class="blue">+10</td>
              <td>Finally correct naming!</td>
            </tr>
            <tr>
              <td>Method Injection</td>
              <td>15</td>
              <td class="blue">+2</td>
              <td>Almost perfect</td>
            </tr>
            <tr>
              <td>Main Method</td>
              <td>20</td>
              <td class="blue">+5</td>
              <td>Excellent demonstration</td>
            </tr>
            <tr>
              <td>Knowledge Quiz</td>
              <td>22</td>
              <td class="blue">+2</td>
              <td>Good understanding</td>
            </tr>
            <tr>
              <td>Scenario Quiz</td>
              <td class="blue">27</td>
              <td class="blue">+5</td>
              <td><strong>Perfect 4/4!</strong></td>
            </tr>
          </tbody>
        </table>

        <h2 id="key-lessons">Key Lessons Learned</h2>

        <h3>1. The Naming Pattern That Changes Everything</h3>
        <pre><code><span class="comment-correct">// The pattern that MUST be consistent:</span>

<span class="comment-correct">// 1. DECLARE the field</span>
<span class="correct">private readonly IType _fieldName;</span>

<span class="comment-correct">// 2. ACCEPT in constructor</span>
<span class="correct">public ClassName(IType parameterName)</span>

<span class="comment-correct">// 3. ASSIGN parameter to field</span>
<span class="correct">_fieldName = parameterName;</span>

<span class="comment-correct">// 4. USE the field</span>
<span class="correct">_fieldName.Method();</span></code></pre>

        <h3>2. Common Naming Mistakes to Avoid</h3>
        <ul>
          <li>
            ‚ùå <code>private readonly IType DatabaseStorage</code> ‚Üí ‚úÖ
            <code>private readonly IType _storage</code>
          </li>
          <li>
            ‚ùå <code>_IType = value</code> ‚Üí ‚úÖ <code>_fieldName = value</code>
          </li>
          <li>
            ‚ùå <code>IType.Method()</code> ‚Üí ‚úÖ <code>_fieldName.Method()</code>
          </li>
          <li>
            ‚ùå Declaring: <code>_storage</code> but using:
            <code>_taskStorage</code>
          </li>
        </ul>

        <h3>3. Syntax Rules That Cost Points</h3>
        <ul>
          <li>
            Interfaces: Method signatures end with <code>;</code> not
            <code>{}</code>
          </li>
          <li>Fields: Must end with <code>;</code></li>
          <li>
            Assignment: <code>field = parameter;</code> NOT
            <code>Type parameter;</code>
          </li>
          <li>
            C# Convention: Private fields start with underscore and camelCase
          </li>
        </ul>

        <h3>4. DI Type Selection Decision Tree</h3>
        <pre><code>Is it critical to operation?
‚îú‚îÄ YES ‚Üí Constructor Injection
‚îî‚îÄ NO ‚Üí How many methods use it?
    ‚îú‚îÄ Most/All ‚Üí Constructor Injection
    ‚îú‚îÄ Some ‚Üí Property Injection  
    ‚îî‚îÄ One specific method ‚Üí Method Injection</code></pre>

        <h3>5. Single Responsibility Principle (SRP)</h3>
        <p>
          Before applying DI, ensure each class has ONE responsibility.
          TaskManager should coordinate tasks, not implement storage,
          notifications, or logging. SRP makes DI necessary because
          single-responsibility classes need other classes to do other work.
        </p>

        <h2 id="comparison">Comparison: Round 1 vs Round 2</h2>
        <table>
          <thead>
            <tr>
              <th>Aspect</th>
              <th>Round 1 (Bank)</th>
              <th>Round 2 (Task Manager)</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><strong>Final Score</strong></td>
              <td>37 points</td>
              <td>27 points</td>
            </tr>
            <tr>
              <td><strong>Lowest Point</strong></td>
              <td>38 points</td>
              <td class="red">3 points</td>
            </tr>
            <tr>
              <td><strong>Main Challenge</strong></td>
              <td>Understanding concepts</td>
              <td>Naming consistency</td>
            </tr>
            <tr>
              <td><strong>Biggest Drop</strong></td>
              <td>-7 points</td>
              <td class="red">-16 points</td>
            </tr>
            <tr>
              <td><strong>Best Recovery</strong></td>
              <td>+4 points</td>
              <td class="blue">+10 points</td>
            </tr>
            <tr>
              <td><strong>Attempts Needed</strong></td>
              <td>~6 attempts</td>
              <td>5 attempts</td>
            </tr>
          </tbody>
        </table>

        <h2>Humor Through the Pain üòÇ</h2>
        <blockquote>
          <p>
            "Current Score: 13 points ‚Üê All lost due to naming. Not a great way
            to go down hahahaha. Do forgive me, I use humor to make pain
            sometimes lighter"
          </p>
          <footer>‚Äî The Learner, at rock bottom (3 points)</footer>
        </blockquote>

        <p>
          This quote perfectly captures the spirit of the learning journey.
          Going from 52 points to 3 points primarily due to
          <code>_ITaskStorage</code> vs <code>_taskStorage</code>
          confusion was painful but created an unforgettable lesson. The humor
          helped push through the frustration, and the recovery from 3 to 27
          points showed true persistence!
        </p>

        <h2>What Makes This Round Different</h2>
        <ol>
          <li>
            <strong>Deeper SRP Understanding:</strong> Took time to understand
            Single Responsibility Principle
          </li>
          <li>
            <strong>Naming Hell:</strong> The score drop was almost entirely
            syntax/naming, not conceptual
          </li>
          <li>
            <strong>Persistence Rewarded:</strong> Kept trying despite dropping
            to 3 points
          </li>
          <li>
            <strong>Perfect Application:</strong> Ended with 4/4 on scenario
            quiz
          </li>
          <li>
            <strong>Muscle Memory Built:</strong> The pain of naming mistakes
            ensures they won't be repeated
          </li>
        </ol>

        <h2 id="conclusion">Conclusion</h2>
        <p>
          Round 2 proved that understanding concepts is only half the battle -
          precise syntax and consistent naming are equally crucial. The journey
          from 52 ‚Üí 3 ‚Üí 27 points demonstrates that mistakes, especially painful
          ones, create the strongest learning. The learner now has a visceral
          understanding that:
        </p>

        <blockquote>
          <p>
            <code>private readonly IType _fieldName;</code><br />
            means you must use <code>_fieldName</code> EVERYWHERE, not
            <code>_IType</code>, not <code>_differentName</code>, not
            <code>IType</code> - only <code>_fieldName</code>.
          </p>
        </blockquote>

        <p>
          This lesson, burned in through point loss, will never be forgotten.
          That's the power of gamified learning with real consequences!
        </p>

        <div class="alert alert-info">
          <strong>Next Steps:</strong> With two rounds complete and all three DI
          types mastered, the learner is ready for Round 3 (E-commerce system),
          dependency chains, or exploring IoC containers like
          Microsoft.Extensions.DependencyInjection.
        </div>
      </article>

      <!-- Return link -->
      <span><a href="../../index.html">Main Page</a></span>
      <span> | </span>
      <span
        ><a href="./dependency-injection.html">Round 1: Bank System</a></span
      >
    </main>
    <footer>
      The
      <a href="https://git.sr.ht/~sircmpwn/drewdevault.com"
        >code for this site</a
      >
      is <a href="https://opensource.org/licenses/MIT">MIT</a>.
    </footer>
  </body>
</html>
