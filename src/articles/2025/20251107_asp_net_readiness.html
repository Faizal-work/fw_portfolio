<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>ASP.NET Core + React Readiness</title>
    <style>
      body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
        line-height: 1.6;
        max-width: 900px;
        margin: 40px auto;
        padding: 0 20px;
        color: #333;
      }
      h1 { color: #2c3e50; border-bottom: 3px solid #3498db; padding-bottom: 10px; }
      h2 { color: #34495e; margin-top: 30px; border-left: 4px solid #3498db; padding-left: 15px; }
      h3 { color: #7f8c8d; }
      .score-badge { 
        background: #3498db; 
        color: white; 
        padding: 3px 10px; 
        border-radius: 12px; 
        font-size: 0.85em;
        font-weight: bold;
      }
      .penalty { background: #e74c3c; }
      .bonus { background: #27ae60; }
      pre { 
        background: #f8f9fa; 
        border-left: 4px solid #3498db; 
        padding: 15px; 
        overflow-x: auto; 
        border-radius: 4px;
      }
      code { 
        background: #f1f3f5; 
        padding: 2px 6px; 
        border-radius: 3px; 
        font-family: 'Consolas', 'Monaco', monospace;
      }
      pre code { background: none; padding: 0; }
      .error { background-color: #fee; color: #c00; }
      .correct { background-color: #efe; color: #060; }
      .highlight { background-color: #ffc; }
      .comment-error { color: #999; font-style: italic; }
      .comment-correct { color: #090; font-style: italic; }
      details { 
        margin: 15px 0; 
        padding: 15px; 
        background: #f8f9fa; 
        border-radius: 6px;
        border: 1px solid #dee2e6;
      }
      summary { 
        cursor: pointer; 
        font-weight: bold; 
        color: #495057;
        padding: 5px;
      }
      summary:hover { color: #3498db; }
      .alert { 
        padding: 15px; 
        margin: 20px 0; 
        border-radius: 6px; 
        border-left: 4px solid;
      }
      .alert-info { background: #d1ecf1; border-color: #0c5460; color: #0c5460; }
      .alert-warning { background: #fff3cd; border-color: #856404; color: #856404; }
      table { 
        width: 100%; 
        border-collapse: collapse; 
        margin: 20px 0;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      }
      th, td { 
        padding: 12px; 
        text-align: left; 
        border-bottom: 1px solid #dee2e6;
      }
      th { 
        background: #3498db; 
        color: white; 
        font-weight: 600;
      }
      tr:hover { background: #f8f9fa; }
      .toc { 
        background: #f8f9fa; 
        padding: 20px; 
        border-radius: 6px; 
        margin: 25px 0;
        border: 1px solid #dee2e6;
      }
      .toc ol { margin-left: 20px; }
      .toc li { margin: 8px 0; }
      .date { color: #7f8c8d; font-size: 0.9em; }
      .stats-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 15px;
        margin: 20px 0;
      }
      .stat-card {
        background: #f8f9fa;
        padding: 15px;
        border-radius: 6px;
        border-left: 4px solid #3498db;
      }
      .stat-card strong { display: block; font-size: 1.5em; color: #3498db; }
    </style>
  </head>
  <body>
    <h1>
      ASP.NET Core + React Full Stack: Bootcamp Preparation
      <small><span class="date">07-November-2025</span> by Ahmad Faizal</small>
    </h1>

    <main>
      <article>
        <h2>Introduction</h2>
        <p>
          This document captures a preparation journey for a pair-programming technical interview. 
          As a Senior Full Stack Developer with 9 years of experience, the goal was to sharpen 
          fundamental skills and build muscle memory through practical, timed challenges.
        </p>

        <div class="alert alert-info">
          <strong>Context:</strong> Interview scheduled for November 11, 2025 (Wednesday). 
          This preparation phase ran from November 7-11, focusing on ASP.NET Core, React, 
          testing patterns, and CRUD operations.
        </div>

        <h3>The Challenge Format</h3>
        <ul>
          <li><strong>Starting Points:</strong> 50</li>
          <li><strong>Penalty System:</strong> -0.2 to -5 points per mistake</li>
          <li><strong>Rewards:</strong> +0.5 to +3 points per successful challenge</li>
          <li><strong>Goal:</strong> Build muscle memory for interview readiness</li>
        </ul>

        <!-- Table of Contents -->
        <div class="toc">
          <h2>üìë Table of Contents</h2>
          <ol>
            <li><a href="#challenge1">Challenge #1: FluentValidation & Query Parameters</a></li>
            <li><a href="#challenge2">Challenge #2: IOptions Configuration Pattern</a></li>
            <li><a href="#challenge3">Challenge #3: Custom Middleware</a></li>
            <li><a href="#challenge4">Challenge #4: React + Axios Integration</a></li>
            <li><a href="#key-mistakes">Common Mistakes & Lessons</a></li>
            <li><a href="#assessment">Honest Assessment</a></li>
            <li><a href="#next-steps">Next Steps: Fresh Bootcamp</a></li>
          </ol>
        </div>

        <h2 id="challenge1">Challenge #1: FluentValidation & Query Parameters</h2>
        <p><strong>Starting Score: 50 points</strong></p>

        <h3>Objective</h3>
        <p>
          Add query parameter validation to the Weather API using FluentValidation. 
          Users should request forecasts for 1-14 days with proper error handling.
        </p>

        <h3>Common Mistakes Made</h3>
        
        <details>
          <summary>Mistake #1: Missing Return Type in Interface <span class="score-badge penalty">-2 points</span></summary>
          <pre><code>public interface IWeatherService
{
    <span class="error">GetWeatherForecast();</span> <span class="comment-error">// ‚ùå No return type!</span>
}</code></pre>
          <p><strong>Lesson:</strong> Interfaces need complete method signatures including return types.</p>
        </details>

        <details>
          <summary>Mistake #2: Incorrect Temperature Conversion <span class="score-badge penalty">-1 point</span></summary>
          <pre><code>public int TemperatureF => 32 + (int)(TemperatureC <span class="error">/ 0.5556</span>); <span class="comment-error">// ‚ùå Should multiply!</span></code></pre>
          <p><strong>Correct Formula:</strong> <code>TemperatureC * 1.8 + 32</code></p>
          <p><strong>Lesson:</strong> Basic formula errors show lack of attention to detail.</p>
        </details>

        <details>
          <summary>Mistake #3: Invalid Cast to IValidationContext <span class="score-badge penalty">-2 points</span></summary>
          <pre><code><span class="error">var validationResult = _validator.Validate((IValidationContext)request);</span> <span class="comment-error">// ‚ùå</span></code></pre>
          <p><strong>Correct:</strong> <code>_validator.Validate(request)</code> - no cast needed!</p>
          <p><strong>Lesson:</strong> Don't overcomplicate. FluentValidation handles this automatically.</p>
        </details>

        <h3>Final Solution <span class="score-badge bonus">+1 point</span></h3>
        <pre><code>// Request Model
public class WeatherForecastRequest
{
    public int Days { get; set; }
}

// Validator
public class WeatherForecastRequestValidator : AbstractValidator&lt;WeatherForecastRequest&gt;
{
    public WeatherForecastRequestValidator()
    {
        RuleFor(x => x.Days)
            .NotEmpty()
            .WithMessage("Days parameter is required.")
            .GreaterThanOrEqualTo(1)
            .WithMessage("Days must be at least 1.")
            .LessThanOrEqualTo(14)
            .WithMessage("Days cannot exceed 14.");
    }
}

// Controller
[HttpGet]
public ActionResult GetWeatherForecast([FromQuery] int days)
{
    var request = new WeatherForecastRequest { Days = days };
    var validationResult = <span class="correct">_validator.Validate(request);</span> <span class="comment-correct">// ‚úÖ Simple!</span>
    
    if (!validationResult.IsValid)
        return BadRequest(validationResult.Errors);
    
    var result = _weatherService.GetWeatherForecast(days);
    return Ok(result);
}</code></pre>

        <p><strong>Score after Challenge #1: 48 points</strong></p>

        <h2 id="challenge2">Challenge #2: IOptions Configuration Pattern</h2>
        <p><strong>Starting Score: 43 points</strong> (adjusted after re-evaluation)</p>

        <h3>Objective</h3>
        <p>
          Implement the IOptions pattern to externalize configuration. Make MaxForecastDays 
          configurable through appsettings.json instead of hardcoded values.
        </p>

        <h3>Common Mistakes Made</h3>

        <details>
          <summary>Mistake #4: Wrong IOptions Type <span class="score-badge penalty">-2 points</span></summary>
          <pre><code>public WeatherService(<span class="error">IOptions&lt;WeatherService&gt;</span> settings) <span class="comment-error">// ‚ùå Self-reference!</span>
{
    _settings = settings.Value;
}</code></pre>
          <p><strong>Correct:</strong> <code>IOptions&lt;WeatherSettings&gt;</code></p>
          <p><strong>Lesson:</strong> IOptions wraps your configuration class, not the service itself.</p>
        </details>

        <details>
          <summary>Mistake #5: Not Using Injected Settings <span class="score-badge penalty">-1 point</span></summary>
          <pre><code>public WeatherService(IOptions&lt;WeatherSettings&gt; settings)
{
    _settings = settings.Value; <span class="comment-error">// ‚úÖ Stored...</span>
}

public WeatherForecast[] GetWeatherForecast(int days)
{
    <span class="error">// ...but never used _settings!</span>
    var forecast = Enumerable.Range(1, days).Select(...);
}</code></pre>
          <p><strong>Lesson:</strong> If you inject it, USE it! Otherwise, why inject?</p>
        </details>

        <h3>Final Solution <span class="score-badge bonus">+2 points</span></h3>
        <pre><code>// Configuration Class
public class WeatherSettings
{
    public int MaxForecastDays { get; set; } = 14;
    public string TemperatureUnit { get; set; } = "Celsius";
    public string DefaultSummary { get; set; } = "Unknown";
}

// appsettings.json
{
  "WeatherSettings": {
    "MaxForecastDays": 14,
    "TemperatureUnit": "Celsius",
    "DefaultSummary": "Mild"
  }
}

// Service
public class WeatherService : IWeatherService
{
    private readonly WeatherSettings _settings;
    
    public WeatherService(IOptions&lt;WeatherSettings&gt; settings)
    {
        _settings = settings.Value;
    }
    
    public WeatherForecast[] GetWeatherForecast(int days)
    {
        <span class="correct">var actualDays = Math.Min(days, _settings.MaxForecastDays);</span> <span class="comment-correct">// ‚úÖ Using it!</span>
        return Enumerable.Range(1, actualDays).Select(...).ToArray();
    }
}

// Program.cs Registration
builder.Services.Configure&lt;WeatherSettings&gt;(
    builder.Configuration.GetSection("WeatherSettings")
);</code></pre>

        <p><strong>Score after Challenge #2: 40.5 points</strong></p>

        <h2 id="challenge3">Challenge #3: Custom Middleware</h2>
        <p><strong>Starting Score: 38 points</strong> (after -15 point deduction for external help)</p>

        <h3>Objective</h3>
        <p>
          Create custom middleware to track request timing and add performance headers 
          to all responses. This is a production pattern for monitoring and debugging.
        </p>

        <h3>Common Mistakes Made</h3>

        <details>
          <summary>Mistake #6: Headers Set After Response Started <span class="score-badge penalty">-3 points</span></summary>
          <pre><code>public async Task InvokeAsync(HttpContext context)
{
    var stopwatch = Stopwatch.StartNew();
    
    await _next(context); <span class="comment-error">// Response body written</span>
    
    stopwatch.Stop();
    <span class="error">context.Response.Headers["X-Response-Time-ms"] = elapsed.ToString();</span> <span class="comment-error">// ‚ùå Too late!</span>
}</code></pre>
          <p><strong>Error:</strong> "Headers are read-only, response has already started."</p>
          <p><strong>Lesson:</strong> Headers must be set BEFORE response body is written.</p>
        </details>

        <details>
          <summary>Mistake #7: Constructor Assignment Backwards <span class="score-badge penalty">-1 point</span></summary>
          <pre><code>public RequestTimingMiddleware(RequestDelegate next, ILogger logger)
{
    <span class="error">next = _next;</span> <span class="comment-error">// ‚ùå Backwards!</span>
    <span class="error">logger = _logger;</span>
}</code></pre>
          <p><strong>Correct:</strong> <code>_next = next;</code> (field = parameter)</p>
          <p><strong>Lesson:</strong> Basic C# syntax - assignment goes left to right.</p>
        </details>

        <h3>Final Solution <span class="score-badge bonus">+2.5 points</span></h3>
        <pre><code>public class RequestTimingMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger&lt;RequestTimingMiddleware&gt; _logger;

    public RequestTimingMiddleware(RequestDelegate next, ILogger&lt;RequestTimingMiddleware&gt; logger)
    {
        <span class="correct">_next = next;</span>
        <span class="correct">_logger = logger;</span>
    }

    public async Task InvokeAsync(HttpContext context)
    {
        var stopwatch = Stopwatch.StartNew();

        <span class="comment-correct">// ‚úÖ Register callback to add header BEFORE response starts</span>
        <span class="correct">context.Response.OnStarting(() =>
        {
            stopwatch.Stop();
            var elapsed = stopwatch.ElapsedMilliseconds;
            context.Response.Headers["X-Response-Time-ms"] = elapsed.ToString();
            return Task.CompletedTask;
        });</span>

        try
        {
            await _next(context);
        }
        finally
        {
            stopwatch.Stop();
            _logger.LogInformation(
                "Request {Method} {Path} completed in {ElapsedMs}ms",
                context.Request.Method,
                context.Request.Path,
                stopwatch.ElapsedMilliseconds);
        }
    }
}

// Extension Method
public static class MiddlewareExtensions
{
    public static IApplicationBuilder UseRequestTiming(this IApplicationBuilder builder)
    {
        return builder.UseMiddleware&lt;RequestTimingMiddleware&gt;();
    }
}

// Program.cs - Correct Order
app.UseRequestTiming();        // 1. Timing (measures everything)
app.UseHttpsRedirection();     // 2. HTTPS
app.UseCors();                 // 3. CORS
app.UseAuthentication();       // 4. Auth
app.UseAuthorization();        // 5. Authorization
app.MapControllers();          // 6. Endpoints</code></pre>

        <p><strong>Score after Challenge #3: 40.5 points</strong></p>

        <h2 id="challenge4">Challenge #4: React + Axios Integration</h2>
        <p><strong>Starting Score: 25.5 points</strong> (after requested -15 penalty for using help)</p>

        <h3>Objective</h3>
        <p>
          Build a React frontend that connects to the ASP.NET API using Axios. 
          Implement proper loading states, error handling, and validation feedback.
        </p>

        <h3>Common Mistakes Made</h3>

        <details>
          <summary>Mistake #8: Wrong Property in Display <span class="score-badge penalty">-0.5 points</span></summary>
          <pre><code>&lt;p&gt;
  &lt;strong&gt;Temp Fahrenheit:&lt;/strong&gt; {forecast.<span class="error">temperatureC</span>}¬∞F
&lt;/p&gt; <span class="comment-error">// ‚ùå Should be temperatureF!</span></code></pre>
          <p><strong>Lesson:</strong> Copy-paste errors happen. Always verify variable names.</p>
        </details>

        <details>
          <summary>Mistake #9: Validation After Loading <span class="score-badge penalty">-1 point</span></summary>
          <pre><code>const handleSubmit = async (e) => {
  e.preventDefault();
  <span class="error">setLoading(true);</span> <span class="comment-error">// ‚ùå Started loading</span>
  
  if (days > 14 || days < 1) {
    setError("Days must be between 1 and 14");
    return; <span class="comment-error">// ‚ùå Loading never stops!</span>
  }
  // ...</code></pre>
          <p><strong>Lesson:</strong> Validate BEFORE setting loading state.</p>
        </details>

        <h3>Final Solution <span class="score-badge bonus">+1.5 points</span></h3>
        <pre><code>// React Component
function App() {
  const [days, setDays] = useState(7);
  const [dataDays, setDataDays] = useState([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  const handleSubmit = async (e) => {
    e.preventDefault();
    
    <span class="comment-correct">// ‚úÖ Validate FIRST</span>
    <span class="correct">if (days > 14 || days < 1) {
      setError("Please ensure the days are in the range of 1 to 14");
      return;
    }</span>
    
    <span class="comment-correct">// ‚úÖ Then start loading</span>
    setLoading(true);
    setError(null);
    
    try {
      const response = await getWeatherForecast(days);
      setDataDays(response.data);
    } catch (e) {
      setError(e.response?.data?.title || "Failed to fetch weather data");
    } finally {
      setLoading(false);
    }
  };

  return (
    &lt;div&gt;
      &lt;form onSubmit={handleSubmit}&gt;
        &lt;input 
          type="number" 
          value={days}
          onChange={(e) =&gt; setDays(Number(e.target.value))}
          min={1}
          max={14}
          disabled={loading}
        /&gt;
        &lt;button type="submit"&gt;
          {loading ? "Loading..." : "Get Forecast"}
        &lt;/button&gt;
      &lt;/form&gt;
      
      {error && &lt;div className="error"&gt;{error}&lt;/div&gt;}
      
      {loading && &lt;div className="spinner"&gt;Loading...&lt;/div&gt;}
      
      {dataDays.map((forecast) => (
        &lt;WeatherCard key={forecast.date} forecast={forecast} /&gt;
      ))}
    &lt;/div&gt;
  );
}

// Axios Service
const API_BASE_URL = import.meta.env.VITE_API_BASE_URL;

const instance = axios.create({
  baseURL: API_BASE_URL,
  headers: { "Content-Type": "application/json" }
});

export const getWeatherForecast = (days) => {
  return instance.get("/weatherforecast", { params: { days } });
};</code></pre>

        <p><strong>Final Score: 27.5 points</strong></p>

        <h2 id="key-mistakes">Common Mistakes & Patterns</h2>

        <div class="stats-grid">
          <div class="stat-card">
            <strong>11</strong>
            Distinct Mistakes
          </div>
          <div class="stat-card">
            <strong>-22.5</strong>
            Total Points Lost
          </div>
          <div class="stat-card">
            <strong>+7</strong>
            Points Gained
          </div>
          <div class="stat-card">
            <strong>27.5</strong>
            Final Score
          </div>
        </div>

        <h3>Recurring Error Patterns</h3>
        <table>
          <thead>
            <tr>
              <th>Error Type</th>
              <th>Occurrences</th>
              <th>Impact</th>
              <th>Root Cause</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Constructor assignment backwards</td>
              <td>2</td>
              <td>High</td>
              <td>Lack of practice</td>
            </tr>
            <tr>
              <td>Variable name typos</td>
              <td>3</td>
              <td>Medium</td>
              <td>Insufficient review</td>
            </tr>
            <tr>
              <td>Logic order mistakes</td>
              <td>4</td>
              <td>High</td>
              <td>Not thinking through flow</td>
            </tr>
            <tr>
              <td>Type/cast errors</td>
              <td>2</td>
              <td>Medium</td>
              <td>Overcomplicating</td>
            </tr>
          </tbody>
        </table>

        <h2 id="assessment">Honest Assessment</h2>

        <h3>Strengths Demonstrated</h3>
        <ul>
          <li>‚úÖ <strong>Architecture Understanding:</strong> Grasps DI, middleware, services</li>
          <li>‚úÖ <strong>Modern Stack:</strong> Comfortable with .NET Core, React, TypeScript</li>
          <li>‚úÖ <strong>Quick Learning:</strong> Fixes issues when pointed out</li>
          <li>‚úÖ <strong>Self-Awareness:</strong> Recognizes mistakes and wants to improve</li>
        </ul>

        <h3>Critical Weaknesses for Interview</h3>
        <ul>
          <li>‚ùå <strong>Syntax Precision:</strong> Too many typos and basic errors</li>
          <li>‚ùå <strong>Logic Flow:</strong> State management order, missing returns</li>
          <li>‚ùå <strong>Speed:</strong> Not fast enough for pair programming</li>
          <li>‚ùå <strong>Testing:</strong> Limited practice with unit tests</li>
          <li>‚ùå <strong>CRUD Operations:</strong> Not drilled sufficiently</li>
        </ul>

        <div class="alert alert-warning">
          <strong>Reality Check:</strong> CV claims 9 years experience, team lead, "championed automated testing" - 
          but making junior-level mistakes. Gap between claimed expertise and demonstrated skills is concerning 
          for a SENIOR role interview.
        </div>

        <h3>Impact on Pair Programming Interview</h3>
        <p>In a live coding session, these mistakes become RED FLAGS:</p>
        <ul>
          <li>üö© <strong>Typos:</strong> "Does he actually code daily?"</li>
          <li>üö© <strong>Logic errors:</strong> "Can he handle complexity?"</li>
          <li>üö© <strong>Slow typing:</strong> "Is he confident?"</li>
          <li>üö© <strong>Pattern violations:</strong> "Does he know best practices?"</li>
        </ul>

        <h2 id="next-steps">Next Steps: Fresh Bootcamp</h2>

        <h3>Decision: Start Fresh with Structured Approach</h3>
        <p>
          After this preparation phase, the decision was made to <strong>start a fresh, structured bootcamp</strong> 
          with the following rationale:
        </p>

        <div class="alert alert-info">
          <strong>Why Fresh Start?</strong>
          <ul>
            <li>Current approach was scattered - jumped between topics</li>
            <li>No deep drilling = weak muscle memory</li>
            <li>38 hours available (Nov 7-11) is enough for complete bootcamp</li>
            <li>Structured progression builds confidence</li>
            <li>Interview requires MASTERY, not surface knowledge</li>
          </ul>
        </div>

        <h3>Proposed Bootcamp Structure</h3>
        <pre>DAY 1 (3 hrs): Clean Architecture + Full CRUD
DAY 2 (5 hrs): Testing Mastery + Entity Framework
DAY 3 (5 hrs): Repository Pattern + Advanced Patterns
DAY 4 (5 hrs): Speed Drills + Interview Scenarios
DAY 5 (6 hrs): Mock Interviews + Bug Fixing
DAY 6 (3 hrs): Light Review + Mental Preparation</pre>

        <h3>Key Differences from This Session</h3>
        <table>
          <thead>
            <tr>
              <th>Current Approach</th>
              <th>Bootcamp Approach</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Scattered learning</td>
              <td>Structured progression</td>
            </tr>
            <tr>
              <td>Each topic once</td>
              <td>Drill until perfect</td>
            </tr>
            <tr>
              <td>No time limits</td>
              <td>Strict time limits</td>
            </tr>
            <tr>
              <td>40% breadth</td>
              <td>90% depth</td>
            </tr>
            <tr>
              <td>Knowledge-focused</td>
              <td>Muscle memory-focused</td>
            </tr>
          </tbody>
        </table>

        <h2>Conclusion</h2>
        <p>
          This preparation phase revealed important gaps between claimed experience and demonstrated skills. 
          The mistakes made were valuable learning opportunities, showing that understanding concepts is 
          different from having coding muscle memory.
        </p>

        <p>
          <strong>Key Takeaway:</strong> For pair programming interviews at senior level, muscle memory and 
          speed matter as much as conceptual understanding. A structured bootcamp with deep drilling is 
          the right approach for the remaining 38 hours before the interview.
        </p>

        <div class="alert alert-info">
          <strong>Lessons for Future Learning:</strong>
          <ul>
            <li>Practice beats theory when time is limited</li>
            <li>Drill fundamentals until automatic</li>
            <li>Every mistake is technical debt in interviews</li>
            <li>Structure > scattered learning</li>
            <li>Honesty about skill gaps enables targeted improvement</li>
          </ul>
        </div>

        <p><em>Document created: November 7, 2025 | Interview: November 11, 2025 | Time remaining: 96 hours</em></p>
      </article>
    </main>
  </body>
</html>